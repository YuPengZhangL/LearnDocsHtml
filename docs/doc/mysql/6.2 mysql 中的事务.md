### mysql 中事务

#### 1.事务的基本概念

- 事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作**要么同时成功，要么同时失败**

**事务的四个基本特性(ACID)**

```text

研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的
    1) 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
    2) 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
    3) 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
    4) 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。
```

![image](./image/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7.png)

```text
而对于这四大特性，实际上分为两个部分。 
    1) 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 
    2) 而持久性是通过数据库的锁，加上MVCC来保证的

在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC
```

#### 2. 事务的基本原理

##### 2.1 redo log

**重做日志**
```text
记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。

该日志文件由两部分组成：
    1) 重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile），前者是在内存中，后者在磁盘中。
    2) 当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。
```

**redo log 的机制以及作用**
- redo log 刷盘示意图

![image](./image/read%20log.png)

- 概念详解
```text
WAL(Write-Ahead Logging)
    1) MySQL 里经常说到的 WAL技术，也就是先写日志，再写磁盘(也就是更新数据之前先更新日志)
    2) 使用WAL的原因是：磁盘的写操作是随机io，比较耗性能，所以如果把每一次的更新操作都先写入log中，那么就成了顺序写操作，实际更新操作由后台线程再根据log异步写入。
    这样对于client端，延迟就降低了。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的io次数也大大降低。所以WAL的核心在于将随机写转变为了顺序写，降低了客户端的延迟，提升了吞吐量。


如果没有redolog，可能会存在什么问题的？

    1) 在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。当我们在一个事务中，执行多个增删改的操作时，
    InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，
    修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。
    2) 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后才将缓冲区的数据刷新到磁盘中，但是当缓冲池中的数据被修改时，用户就已经得到事务提交成功的信息了。
    在这种情况下，如果脏页刷新到磁盘的过程出错了，就会出现用户明明得到了事务提交成功的提示，而但据却没有持久化下来的现象，这就出现问题了，事务的持久性并没有得到保证

redo log可以恢复数据
    
    1) 有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。
    2) 在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。
    3) 过一段时间之后，如果刷新缓冲区的脏页到磁盘时发生错误，就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。
    4) 如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就失去了作用，可以被删除了，所以存在的两个redolog文件，通过循环写的形式，新写入的日志会将旧日志覆盖。
```
##### 2.2 undo log
**回滚日志**
```text
1) 用于记录数据被修改前的信息 , 作用包含两个：提供回滚(保证事务的原子性) 和MVCC(多版本并发控制)

2) undo log和redo log记录物理日志不一样，它是逻辑日志,可以认为当执行一条增删改操作的时候，它记录一条对应相反的记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。

3) undo log 的周期
    Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。

    Undo log存储：undo log采用段的方式进行管理和记录，存放在 rollback segment回滚段中，内部包含1024个undo log segment。
```


#### 3. redo log/undo log/bin log 比较

```text
1、undo log是用于事务的回滚、保证事务隔离级别读已提交、可重复读实现的。redo log是用于对暂不更新到磁盘上的操作进行记录，使得其可以延迟落盘，保证程序的效率。bin log是对数据操作进行备份恢复（并不能依靠 bin log 直接完成数据恢复）。

2、undo log 与 redo log 是存储引擎层的日志，只能在 InnoDB 下使用；而bin log 是 Server 层的日志，可以在任何引擎下使用。

3、redo log 大小有限，超过后会循环写；另外两个大小不会。

4、undo log 记录的是行记录变化前的数据；redo log 记录的是 sql 的数据页修改逻辑以及 change buffer 的变更；bin log记录操作语句对具体行的操作以及操作前的整行信息（5.7默认）或者sql语句。

5、单独的 binlog 没有 crash-safe 能力，也就是在异常断电后，之前已经提交但未更新的事务操作到磁盘的操作会丢失，也就是主从复制的一致性无法保障，而 redo log 有 crash-safe 能力，通过与 redo log 的配合实现 "三步提交"，就可以让主从库的数据也能保证一致性。

6、redo log 是物理日志，它记录的是数据页修改逻辑以及 change buffer 的变更，只能在当前存储引擎下使用，而 binlog 是逻辑日志，它记录的是操作语句涉及的每一行修改前后的值，在任何存储引擎下都可以使用。

```
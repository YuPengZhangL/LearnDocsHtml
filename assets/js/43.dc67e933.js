(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{413:function(_,v,t){"use strict";t.r(v);var e=t(10),s=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"mq-message-queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mq-message-queue"}},[_._v("#")]),_._v(" MQ(Message Queue)")]),_._v(" "),v("h3",{attrs:{id:"_1-什么是mq-消息队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是mq-消息队列"}},[_._v("#")]),_._v(" 1. 什么是MQ(消息队列)?")]),_._v(" "),v("blockquote",[v("ol",[v("li",[_._v("MQ(message queue)，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是 message 而已，还是一种跨进程的通信机制，用于上下游传递消息。")]),_._v(" "),v("li",[_._v("在互联网架构中，MQ 是一种非常常 见的上下游「逻辑解耦 + 物理解耦」的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。")])])]),_._v(" "),v("h3",{attrs:{id:"_2-mq-解决的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-mq-解决的优缺点"}},[_._v("#")]),_._v(" 2. MQ 解决的优缺点")]),_._v(" "),v("ul",[v("li",[_._v("业务异步解耦")])]),_._v(" "),v("blockquote",[v("p",[_._v("允许独立的扩展或者修改Queue两边的处理过程，只需要遵守同样的接口约束即可")])]),_._v(" "),v("ul",[v("li",[_._v("可恢复性")])]),_._v(" "),v("blockquote",[v("p",[_._v("系统一部分组件失效时，不会影响到整个系统，mq降低了系统之间的耦合度，即使一个处理消息的进程崩了，已经加入mq的信息可以在系统恢复后进行处理")])]),_._v(" "),v("ul",[v("li",[_._v("缓冲")])]),_._v(" "),v("blockquote",[v("p",[_._v("有助于处理和优化数据流经过系统的速度，解决生产消费处理速度不一致的情况")])]),_._v(" "),v("ul",[v("li",[_._v("灵活性 & 峰值处理")])]),_._v(" "),v("blockquote",[v("p",[_._v("可以预防突发的访问压力，使系统关键组件不至于崩溃")])]),_._v(" "),v("ul",[v("li",[_._v("异步通信")])]),_._v(" "),v("blockquote",[v("p",[_._v("生产和消费不需要强耦合，用户将消息放入到mq中，不需要立即处理，可以放多个，然后再需要的时间进行处理")])]),_._v(" "),v("p",[v("strong",[_._v("缺点")])]),_._v(" "),v("ul",[v("li",[_._v("系统可用性降低")]),_._v(" "),v("li",[_._v("系统复杂性提高")]),_._v(" "),v("li",[_._v("一致性问题")])]),_._v(" "),v("h3",{attrs:{id:"_3-mq的两种模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-mq的两种模式"}},[_._v("#")]),_._v(" 3. MQ的两种模式")]),_._v(" "),v("h5",{attrs:{id:"_3-1-消息发布的两种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-消息发布的两种方式"}},[_._v("#")]),_._v(" 3.1 "),v("strong",[_._v("消息发布的两种方式")])]),_._v(" "),v("blockquote",[v("p",[_._v("消费者自己主动拉取\nMQ主动推")])]),_._v(" "),v("p",[v("strong",[_._v("点对点模式")])]),_._v(" "),v("blockquote",[v("ol",[v("li",[_._v("一对一，消费者主动拉取数据，消息收到后清除消息")]),_._v(" "),v("li",[_._v("生产者在生产消息发送到Q中，之后消费者从Q中取出消息并消费，消息被消费之后Q中不在存储消息，所有消费者不能消费到已经被消费的消息。")]),_._v(" "),v("li",[_._v("Q 支持多个消费者，但是一个消息只能被一个消费者消费到")])])]),_._v(" "),v("p",[v("strong",[_._v("发布订阅模式")])]),_._v(" "),v("blockquote",[v("ol",[v("li",[_._v("一对多，消费者消费数据之后不会立即清除数据")]),_._v(" "),v("li",[_._v("生产者（发布）讲消息发送到topic中，同时有多个消费知（订阅）消费该消息，发不到topic的消息会被所有消费者消费")])])])])}),[],!1,null,null,null);v.default=s.exports}}]);
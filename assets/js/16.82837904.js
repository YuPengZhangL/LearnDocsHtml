(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{340:function(s,n,t){s.exports=t.p+"assets/img/channel.aa6db934.png"},341:function(s,n,t){s.exports=t.p+"assets/img/iface_linker.efbe9d9c.png"},408:function(s,n,t){"use strict";t.r(n);var a=t(10),e=Object(a.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"golang-数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#golang-数据类型"}},[s._v("#")]),s._v(" Golang 数据类型")]),s._v(" "),n("h3",{attrs:{id:"_1-golang-中的引用类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-golang-中的引用类型"}},[s._v("#")]),s._v(" 1. golang 中的引用类型")]),s._v(" "),n("blockquote",[n("p",[s._v("引用类型是 map,slice,channel")])]),s._v(" "),n("h4",{attrs:{id:"_1-1-slice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-slice"}},[s._v("#")]),s._v(" 1.1 Slice")]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 1. slice 赋值 ")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n切片 slice 的赋值操作是改变了 slice 内部结构的值. 所以赋值后改变的是指针 array 指向的地址、len 和 cap 值. 赋值操作的左、右俩个切片的 array 指向的是同一个数组，所以它们的数组中元素的值也会一起发生改变\n*/")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 2. slic 拷贝")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n对于切片直接用 = 拷贝，实际上是浅拷贝，只是改变了指针的指向，并没有改变数组中元素的值. 对于深度拷贝的需求，可以借助 copy 内置函数完成\n*/")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 3. 函数传递")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\ngolang 函数的参数传递都是值传递，而 map、channel、slice 都是引用类型，会传递指针值. 但是，切片的结构及扩容机制特殊\n在切片进行复制时，会将切片的值（指针、cap、len)复制了一份. 在函数内部可以改变原切片的值.\n*/")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 4. 切片 slice 的扩容")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n1) 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）\n2) 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=2cap）\n3) 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）\n4) 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）\n*/")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" slice "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    array unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 指向数组的指针")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("len")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int")]),s._v("            "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 切片中元素的数量")]),s._v("\n    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("cap")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int")]),s._v("            "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// array 数组的总容量")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br")])]),n("h4",{attrs:{id:"_1-2-map"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-map"}},[s._v("#")]),s._v(" 1.2 Map")]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// map 的底层本质上是实现散列表，它解决碰撞的方式是拉链法. map 在进行扩容时不会立即替换原内存，而是慢慢的通过 GC 方式释放")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// map的底层结构")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" hmap "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  count     "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int")]),s._v(" \n  flags     "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint8")]),s._v("\n  B         "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint8")]),s._v(" \n  noverflow "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint16")]),s._v(" \n  hash0     "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint32")]),s._v(" \n  buckets    unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer\n  oldbuckets unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer \n  nevacuate  "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uintptr")]),s._v("        \n  extra "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("mapextra\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\nbuckets、oldbuckets 是指向存储键值的内存地址, 其中 oldbuckets 用于在扩容时候，指向旧的 bucket 地址，再下次访问时不断的将 oldbuckets 值转移到 buckets 中. oldbuckets 并不直接释放内存，而是通过不引用，交由 gc 释放内存\n*/")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// hmap 散列表和bucket")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n1. hmap 中核心的结构是 buckets，它是 bucket 数组，其中每个 bucket 是一个链表. 这个结构其实就是散列表的实现，通过拉链法消除 hash 冲突. 使得散列表能够存储更多的元素，同时避免过大的连续内存申请.\n\n2. 在哈希表结构中有一个加载因子(即 loadFactor), 它一般是散列包含的元素数除以位置总数. 加载因子越高，冲突产生的概率越高. \n当达到一定阈值时，就该为哈希表进行扩容了，否则查询效率将会很低.\n当 golang map 的加载因子大于阈值时，len(map) / 2 ^ B > 6.5 时 ，就会对 map 对象进行扩容. \n扩容不会立刻释放掉原来的 bucket 内存，而是由 oldbucket 指向，并产生新的 buckets 数组并由指针 buckets 指向. \n在再次访问原数据时，再依次将老的 bucket 移到新的 buckets 数组中. 同时解除对老的 bucket 的引用，GC 会统一释放掉这些内存\n\n3. 哈希函数通过 key 值计算哈希，快速映射到数据的地址. golang 的 map 进行哈希计算后，将结果分为高位值和低位值，其中低位值用于定位 buckets 数组中的具体 bucket，而高位值用于定位这个 bucket 链表中具体的 key \n*/")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br")])]),n("h4",{attrs:{id:"_1-3-channel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-channel"}},[s._v("#")]),s._v(" 1.3 Channel")]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// chan 结构为hchan，其中主要包括 buf、sendx、recvx、sendq、recvq...")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" hchan "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\tqcount   "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint")]),s._v("           "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 队列中所有数据总数")]),s._v("\n\tdataqsiz "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint")]),s._v("           "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 环形队列的 size")]),s._v("\n\tbuf      unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 指向 dataqsiz 长度的数组")]),s._v("\n\telemsize "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint16")]),s._v("         "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 元素大小")]),s._v("\n\tclosed   "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint32")]),s._v("\n\telemtype "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type         "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 元素类型")]),s._v("\n\tsendx    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint")]),s._v("           "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 已发送的元素在环形队列中的位置")]),s._v("\n\trecvx    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint")]),s._v("           "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 已接收的元素在环形队列中的位置")]),s._v("\n\trecvq    waitq          "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 接收者的等待队列")]),s._v("\n\tsendq    waitq          "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 发送者的等待队列")]),s._v("\n\n\tlock mutex\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\nbuf: 有缓冲通道用于存储缓存数据的空间, 它是一个循环链表.\nsendx 和 recvx: 用于记录循环链表 buf 中的发送或者接受的 index.\nsendq 和 recvq: 是俩个双向队列，分别是发送、接受的 goroutine 抽象出来的 sudog 结构体的队列.\nlock: 保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready），因为这会因为堆栈 shrinking 而发生死锁\n*/")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br")])]),n("p",[n("img",{attrs:{src:t(340),alt:"image"}})]),s._v(" "),n("blockquote",[n("p",[s._v("channel 最核心的数据结构是 sudog。sudog 代表了一个在等待队列中的 g。sudog 是 Go 中非常重要的数据结构，因为 g 与同步对象关系是多对多的。一个 g 可以出现在许多等待队列上，因此一个 g 可能有很多sudog。并且多个 g 可能正在等待同一个同步对象，因此一个对象可能有许多 sudog。sudog 是从特殊池中分配出来的。使用 acquireSudog 和 releaseSudog 分配和释放它们")])]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" sudog "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\tg "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("g\n\n\tnext "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("sudog\n\tprev "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("sudog\n\telem unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 指向数据 (可能指向栈)")]),s._v("\n\n\tacquiretime "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int64")]),s._v("\n\treleasetime "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int64")]),s._v("\n\tticket      "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint32")]),s._v("\n\n\tisSelect "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("bool")]),s._v("\n\tsuccess "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("bool")]),s._v("\n\n\tparent   "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("sudog     "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// semaRoot 二叉树")]),s._v("\n\twaitlink "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("sudog     "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// g.waiting 列表或者 semaRoot")]),s._v("\n\twaittail "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("sudog     "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// semaRoot")]),s._v("\n\tc        "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("hchan     "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// channel")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("blockquote",[n("p",[s._v("sudog 中所有字段都受 hchan.lock 保护。acquiretime、releasetime、ticket 这三个字段永远不会被同时访问。对 channel 来说，waitlink 只由 g 使用。对 semaphores 来说，只有在持有 semaRoot 锁的时候才能访问这三个字段。isSelect 表示 g 是否被选择，g.selectDone 必须进行 CAS 才能在被唤醒的竞争中胜出。success 表示 channel c 上的通信是否成功。如果 goroutine 在 channel c 上传了一个值而被唤醒，则为 true；如果因为 c 关闭而被唤醒，则为 false")])]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[s._v("ch1 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("make")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("chan")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 无缓冲通道")]),s._v("\nch2 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("make")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("chan")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 有缓冲通道")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 本质上是创建了一个 hchan 结构体，返回指针 ch1 . ")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// chan 在 go 语言中是引用类型, 在参数传递过程是复制的是这个指针值")]),s._v("\n\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// send 和 recv")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n首先会使用 lock 锁住 hchan. 然后以 sendx 或 recvx 序号，在循环链表 buf 指定的位置上找到数据，将数据 copy 到 goroutine 或者时从 goroutine copy 的 buf 上. 然后释放锁\n*/")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 关闭chan")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("close")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ch"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 编译器会将其转换为 runtime.closechan() 方法")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v('/*\nChannel都有哪些特性？\n\n给一个 nil channel 发送数据，造成永远阻塞\n\n从一个 nil channel 接收数据，造成永远阻塞\n\n给一个已经关闭的 channel 发送数据，引起 panic\n\n从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值\n\n无缓冲的channel是同步的，而有缓冲的channel是非同步的\n\n总结： "空读写阻塞，写关闭异常，读关闭空零"\n*/')]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br")])]),n("h3",{attrs:{id:"_2-interface-的原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-interface-的原理"}},[s._v("#")]),s._v(" 2. interface 的原理")]),s._v(" "),n("blockquote",[n("p",[s._v("interface 可以用在任何使用变量的地方。可以作为结构体内的字段，可以作为函数的形参和返回值，可以作为其他 interface 定义的内嵌字段")])]),s._v(" "),n("p",[n("strong",[s._v("非空 interface 数据结构")])]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 非空的 interface 初始化的底层数据结构是 iface")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// tab 中存放的是类型、方法等信息")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// data 指针指向的 iface 绑定对象的原始数据的副本，其中tab 是 itab 类型的指针")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" iface "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\ttab  "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("itab\n\tdata unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\ninner 存的是 interface 自己的静态类型\n_type 存的是 interface 对应具体对象的类型\n_type 是这个变量对应的类型，data 是这个变量的值\nfun 是一个函数指针，它指向的是具体类型的函数方法,这个指针对应内存地址的后面依次存储了多个方法，利用指针偏移便可以找到它们\n*/")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" itab "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\tinter "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("interfacetype\n\t_type "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type\n\thash  "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint32")]),s._v(" \n\t"),n("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("_")]),s._v("     "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("4")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("byte")]),s._v("\n\tfun   "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uintptr")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" _type "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\tsize       "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uintptr")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 类型占用内存大小")]),s._v("\n\tptrdata    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uintptr")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 包含所有指针的内存前缀大小")]),s._v("\n\thash       "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint32")]),s._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 类型 hash")]),s._v("\n\ttflag      tflag   "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 标记位，主要用于反射")]),s._v("\n\talign      "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint8")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 对齐字节信息")]),s._v("\n\tfieldAlign "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint8")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 当前结构字段的对齐字节数")]),s._v("\n\tkind       "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uint8")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 基础类型枚举值")]),s._v("\n\tequal "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("bool")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 比较两个形参对应对象的类型是否相等")]),s._v("\n\tgcdata    "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("byte")]),s._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// GC 类型的数据")]),s._v("\n\tstr       nameOff  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 类型名称字符串在二进制文件段中的偏移量")]),s._v("\n\tptrToThis typeOff  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 类型元信息指针在二进制文件段中的偏移量")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// str 和 ptrToThis，对应的类型是 nameoff 和 typeOff。这两个字段的值是在链接器段合并和符号重定向的时候赋值的")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br"),n("span",{staticClass:"line-number"},[s._v("34")]),n("br"),n("span",{staticClass:"line-number"},[s._v("35")]),n("br"),n("span",{staticClass:"line-number"},[s._v("36")]),n("br"),n("span",{staticClass:"line-number"},[s._v("37")]),n("br"),n("span",{staticClass:"line-number"},[s._v("38")]),n("br")])]),n("p",[n("img",{attrs:{src:t(341),alt:"image"}})]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/*\n链接器将各个 .o 文件中的段合并到输出文件，会进行段合并，有的放入 .text 段，有的放入 .data 段，有的放入 .bss 段。name 和 type 针对最终输出文件所在段内的偏移量 offset 是由 resolveNameOff 和 resolveTypeOff 函数计算出来的，然后链接器把结果保存在 str 和 ptrToThis 中\n*/")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("resolveNameOff")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ptrInModule unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" off nameOff"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" name "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("  \n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("resolveTypeOff")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("ptrInModule unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" off typeOff"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("blockquote",[n("p",[s._v("_type 是所有类型原始信息的元信息")])]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 例如 arraytype 和 chantype 中保存类型的元信息就是靠 _type")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" arraytype "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\ttyp   _type\n\telem  "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type\n\tslice "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type\n\t"),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("len")]),s._v("   "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uintptr")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" chantype "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\ttyp  _type\n\telem "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type\n\tdir  "),n("span",{pre:!0,attrs:{class:"token builtin"}},[s._v("uintptr")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 接口类型定义也依赖与_type")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" imethod "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\tname nameOff\n\tityp typeOff\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" interfacetype "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\ttyp     _type     "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 类型元信息")]),s._v("\n\tpkgpath name      "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 包路径和描述信息等等")]),s._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 函数方法是以包为单位隔离的,所以mhdr 存的是各个 interface 函数方法在段内的偏移值 offset，知道偏移值以后才方便调用")]),s._v("\n  mhdr    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("imethod \n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br")])]),n("p",[n("strong",[s._v("空 interface 数据结构")])]),s._v(" "),n("div",{staticClass:"language-go line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-go"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 空的 inferface{} 是没有方法集的接口,所以不需要 itab 数据结构,它只需要存类型和类型对应的值")]),s._v("\n\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 从以下数据结构可以看出，只有当 2 个字段都为 nil，空接口才为 nil")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("type")]),s._v(" eface "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("struct")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\t_type "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("_type\n\tdata  unsafe"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("Pointer\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);
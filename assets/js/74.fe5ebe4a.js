(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{463:function(t,e,a){"use strict";a.r(e);var s=a(10),n=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"进程、线程、协程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程、线程、协程"}},[t._v("#")]),t._v(" 进程、线程、协程")]),t._v(" "),e("h3",{attrs:{id:"_1-进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-进程"}},[t._v("#")]),t._v(" 1. 进程")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("程序")]),t._v("是一些保存在磁盘上的指令的有序集合，是静态的。"),e("strong",[t._v("进程是程序执行的过程")]),t._v("，包括了动态创建、调度和消亡的整个过程，"),e("strong",[t._v("进程是程序资源管理的最小单位")])])]),t._v(" "),e("p",[e("strong",[t._v("进程一般由程序、数据集合和进程控制块三部分组成")])]),t._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("- 程序用于描述进程要完成的功能，是控制进程执行的指令集；\n- 数据集合是程序在执行时所需要的数据和工作区；\n- 程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("p",[e("strong",[t._v("进程具有的特征")])]),t._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；\n- 并发性：任何进程都可以同其他进程一起并发执行；\n- 独立性：进程是系统进行资源分配和调度的一个独立单位；\n- 结构性：进程由程序、数据和进程控制块三部分组成。\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h3",{attrs:{id:"_2-线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-线程"}},[t._v("#")]),t._v(" 2. 线程")]),t._v(" "),e("blockquote",[e("p",[t._v("线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。")])]),t._v(" "),e("h4",{attrs:{id:"_2-1-进程与线程的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-进程与线程的区别"}},[t._v("#")]),t._v(" 2.1 进程与线程的区别")]),t._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；\n2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；\n3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；\n4. 调度和切换：线程上下文切换比进程上下文切换要快得多。\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h3",{attrs:{id:"_3-协程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-协程"}},[t._v("#")]),t._v(" 3. 协程")]),t._v(" "),e("blockquote",[e("p",[t._v("协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性")])]),t._v(" "),e("h4",{attrs:{id:"_3-1-协程的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-协程的特点"}},[t._v("#")]),t._v(" 3.1 协程的特点")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("1. 线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。\n2. 线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。\n3. 由于在同一个线程上，因此可以避免竞争关系而使用锁。\n4. 适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("h4",{attrs:{id:"_3-2-协程的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-协程的原理"}},[t._v("#")]),t._v(" 3.2 协程的原理")]),t._v(" "),e("blockquote",[e("p",[t._v("当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由"),e("code",[t._v("coroutine")]),t._v("负责调度的线程称为"),e("code",[t._v("Fiber")]),t._v("。比如Golang里的 go关键字其实就是负责开启一个"),e("code",[t._v("Fiber")]),t._v("，让"),e("code",[t._v("func")]),t._v("逻辑跑在上面。")])]),t._v(" "),e("blockquote",[e("p",[t._v("由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。 因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。")])]),t._v(" "),e("h4",{attrs:{id:"_3-3-协程和线程的比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-协程和线程的比较"}},[t._v("#")]),t._v(" 3.3 协程和线程的比较")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[t._v("比较项")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("线程")]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[t._v("协程")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("占用资源")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("初始单位为1MB,固定不可变")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("初始一般为 2KB，可随需要而增大")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("调度所属")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("由 OS 的内核完成")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("由用户完成")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("切换开销")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("涉及模式切换(从用户态切换到内核态)、16个寄存器、PC、SP...等寄存器的刷新等")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("只有三个寄存器的值修改 - PC / SP / DX.")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("性能问题")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("资源占用太高，频繁创建销毁会带来严重的性能问题")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("资源占用小,不会带来严重的性能问题")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("数据同步")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("需要用锁等机制确保数据的一直性和可见性")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。")])])])])])}),[],!1,null,null,null);e.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{381:function(s,e,a){s.exports=a.p+"assets/img/redis过期策略.c8db46ad.png"},453:function(s,e,a){"use strict";a.r(e);var t=a(10),n=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"redis-的「内存淘汰策略」和「过期删除策略」"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-的「内存淘汰策略」和「过期删除策略」"}},[s._v("#")]),s._v(" Redis 的「内存淘汰策略」和「过期删除策略」")]),s._v(" "),e("p",[e("img",{attrs:{src:a(381),alt:"image"}})]),s._v(" "),e("h3",{attrs:{id:"_1-过期删除策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-过期删除策略"}},[s._v("#")]),s._v(" 1. 过期删除策略")]),s._v(" "),e("blockquote",[e("p",[s._v("Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。")])]),s._v(" "),e("div",{staticClass:"language-redis line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("expire <key> <n>：设置 key 在 n 秒后过期\npexpire <key> <n>：设置 key 在 n 毫秒后过期\nexpireat <key> <n>：设置 key 在某个时间戳（精确到秒）之后过期\npexpireat <key> <n>：设置 key 在某个时间戳（精确到毫秒）之后过期\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("设置字符串时，也可以同时对 key 设置过期时间，共有 3 种命令：")]),s._v(" "),e("blockquote",[e("p",[s._v("set <key> <value> ex <n> ：设置键值对的时候，同时指定过期时间（精确到秒）")]),s._v(" "),e("p",[s._v("set <key> <value> px <n> ：设置键值对的时候，同时指定过期时间（精确到毫秒）")]),s._v(" "),e("p",[s._v("setex <key> <n> <valule> ：设置键值对的时候，同时指定过期时间（精确到秒）")])]),s._v(" "),e("p",[s._v("常见的三种过期删除策略")]),s._v(" "),e("h4",{attrs:{id:"_1-1-定时删除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-定时删除"}},[s._v("#")]),s._v(" 1.1 定时删除")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("定时删除策略是怎么样的？")])])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("定时删除策略的做法是，在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("定时删除的优缺点是？")])])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("定时删除策略的优点：\n\t可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。\n\n定时删除策略的缺点：\n\t在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h4",{attrs:{id:"_1-2-惰性删除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-惰性删除"}},[s._v("#")]),s._v(" 1.2 惰性删除")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("惰性删除策略是怎么样的？")])])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("惰性删除的优缺点是？")])])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("惰性删除策略的优点：\n\t因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。\n\n惰性删除策略的缺点：\n\t如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("h4",{attrs:{id:"_1-3-定期删除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-定期删除"}},[s._v("#")]),s._v(" 1.3 定期删除")]),s._v(" "),e("blockquote",[e("ol",[e("li",[s._v("定期删除策略是怎么样的？")])])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("定期删除策略的做法是，每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("blockquote",[e("ol",{attrs:{start:"2"}},[e("li",[s._v("定期删除的优缺点是？")])])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("定期删除策略的优点：\n\t通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。\n\n定期删除策略的缺点：\n\t内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。\n\t难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("h3",{attrs:{id:"_2-内存淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-内存淘汰策略"}},[s._v("#")]),s._v(" 2. 内存淘汰策略")]),s._v(" "),e("blockquote",[e("p",[s._v("当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行")])]),s._v(" "),e("h4",{attrs:{id:"_2-1-redis-内存淘汰策略有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-redis-内存淘汰策略有哪些"}},[s._v("#")]),s._v(" 2.1 Redis 内存淘汰策略有哪些？")]),s._v(" "),e("blockquote",[e("p",[s._v("Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略")])]),s._v(" "),e("blockquote",[e("p",[e("strong",[s._v("不进行数据淘汰的策略:")]),s._v(" noeviction（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，而是不再提供服务，直接返回错误")])]),s._v(" "),e("h4",{attrs:{id:"_2-2-进行数据淘汰的策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-进行数据淘汰的策略"}},[s._v("#")]),s._v(" 2.2.进行数据淘汰的策略")]),s._v(" "),e("ul",[e("li",[s._v("在设置了过期时间的数据中进行淘汰")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("volatile-random：随机淘汰设置了过期时间的任意键值；\nvolatile-ttl：优先淘汰更早过期的键值。\nvolatile-lru（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；\nvolatile-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("ul",[e("li",[s._v("在所有数据范围内进行淘汰")])]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("allkeys-random：随机淘汰任意键值;\nallkeys-lru：淘汰整个键值中最久未使用的键值；\nallkeys-lfu（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h4",{attrs:{id:"_2-3-lru-lfu"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-lru-lfu"}},[s._v("#")]),s._v(" 2.3 LRU & LFU")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("LRU 算法？")])])]),s._v(" "),e("blockquote",[e("p",[s._v("LRU 全称是 Least Recently Used 翻译为最近最少使用，会选择淘汰最近最少使用的数据。")]),s._v(" "),e("p",[s._v("传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。")])]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("LFU 算法？")])])]),s._v(" "),e("blockquote",[e("p",[s._v("LFU 全称是 Least Frequently Used 翻译为最近最不常用的，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。")]),s._v(" "),e("p",[s._v("LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);
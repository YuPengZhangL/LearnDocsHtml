(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{364:function(s,n,a){s.exports=a.p+"assets/img/事务的四个特性.0db5443c.png"},365:function(s,n,a){s.exports=a.p+"assets/img/read log.9ffc4c3a.png"},436:function(s,n,a){"use strict";a.r(n);var e=a(10),l=Object(e.a)({},(function(){var s=this,n=s._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h3",{attrs:{id:"mysql-中事务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mysql-中事务"}},[s._v("#")]),s._v(" mysql 中事务")]),s._v(" "),n("h4",{attrs:{id:"_1-事务的基本概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务的基本概念"}},[s._v("#")]),s._v(" 1.事务的基本概念")]),s._v(" "),n("ul",[n("li",[s._v("事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作"),n("strong",[s._v("要么同时成功，要么同时失败")])])]),s._v(" "),n("p",[n("strong",[s._v("事务的四个基本特性(ACID)")])]),s._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\n研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的\n    1) 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。\n    2) 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。\n    3) 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。\n    4) 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])]),n("p",[n("img",{attrs:{src:a(364),alt:"image"}})]),s._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("而对于这四大特性，实际上分为两个部分。 \n    1) 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 \n    2) 而持久性是通过数据库的锁，加上MVCC来保证的\n\n在讲解事务原理的时候，主要就是来研究一下redolog，undolog以及MVCC\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("h4",{attrs:{id:"_2-事务的基本原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-事务的基本原理"}},[s._v("#")]),s._v(" 2. 事务的基本原理")]),s._v(" "),n("h5",{attrs:{id:"_2-1-redo-log"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-redo-log"}},[s._v("#")]),s._v(" 2.1 redo log")]),s._v(" "),n("p",[n("strong",[s._v("重做日志")])]),s._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。\n\n该日志文件由两部分组成：\n    1) 重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile），前者是在内存中，后者在磁盘中。\n    2) 当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br")])]),n("p",[n("strong",[s._v("redo log 的机制以及作用")])]),s._v(" "),n("ul",[n("li",[s._v("redo log 刷盘示意图")])]),s._v(" "),n("p",[n("img",{attrs:{src:a(365),alt:"image"}})]),s._v(" "),n("ul",[n("li",[s._v("概念详解")])]),s._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("WAL(Write-Ahead Logging)\n    1) MySQL 里经常说到的 WAL技术，也就是先写日志，再写磁盘(也就是更新数据之前先更新日志)\n    2) 使用WAL的原因是：磁盘的写操作是随机io，比较耗性能，所以如果把每一次的更新操作都先写入log中，那么就成了顺序写操作，实际更新操作由后台线程再根据log异步写入。\n    这样对于client端，延迟就降低了。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的io次数也大大降低。所以WAL的核心在于将随机写转变为了顺序写，降低了客户端的延迟，提升了吞吐量。\n\n\n如果没有redolog，可能会存在什么问题的？\n\n    1) 在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。当我们在一个事务中，执行多个增删改的操作时，\n    InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，\n    修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。\n    2) 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后才将缓冲区的数据刷新到磁盘中，但是当缓冲池中的数据被修改时，用户就已经得到事务提交成功的信息了。\n    在这种情况下，如果脏页刷新到磁盘的过程出错了，就会出现用户明明得到了事务提交成功的提示，而但据却没有持久化下来的现象，这就出现问题了，事务的持久性并没有得到保证\n\nredo log可以恢复数据\n    \n    1) 有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。\n    2) 在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。\n    3) 过一段时间之后，如果刷新缓冲区的脏页到磁盘时发生错误，就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。\n    4) 如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redolog就失去了作用，可以被删除了，所以存在的两个redolog文件，通过循环写的形式，新写入的日志会将旧日志覆盖。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br")])]),n("h5",{attrs:{id:"_2-2-undo-log"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-undo-log"}},[s._v("#")]),s._v(" 2.2 undo log")]),s._v(" "),n("p",[n("strong",[s._v("回滚日志")])]),s._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1) 用于记录数据被修改前的信息 , 作用包含两个：提供回滚(保证事务的原子性) 和MVCC(多版本并发控制)\n\n2) undo log和redo log记录物理日志不一样，它是逻辑日志,可以认为当执行一条增删改操作的时候，它记录一条对应相反的记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。\n\n3) undo log 的周期\n    Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。\n\n    Undo log存储：undo log采用段的方式进行管理和记录，存放在 rollback segment回滚段中，内部包含1024个undo log segment。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("h4",{attrs:{id:"_3-redo-log-undo-log-bin-log-比较"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-redo-log-undo-log-bin-log-比较"}},[s._v("#")]),s._v(" 3. redo log/undo log/bin log 比较")]),s._v(" "),n("div",{staticClass:"language-text line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v('1、undo log是用于事务的回滚、保证事务隔离级别读已提交、可重复读实现的。redo log是用于对暂不更新到磁盘上的操作进行记录，使得其可以延迟落盘，保证程序的效率。bin log是对数据操作进行备份恢复（并不能依靠 bin log 直接完成数据恢复）。\n\n2、undo log 与 redo log 是存储引擎层的日志，只能在 InnoDB 下使用；而bin log 是 Server 层的日志，可以在任何引擎下使用。\n\n3、redo log 大小有限，超过后会循环写；另外两个大小不会。\n\n4、undo log 记录的是行记录变化前的数据；redo log 记录的是 sql 的数据页修改逻辑以及 change buffer 的变更；bin log记录操作语句对具体行的操作以及操作前的整行信息（5.7默认）或者sql语句。\n\n5、单独的 binlog 没有 crash-safe 能力，也就是在异常断电后，之前已经提交但未更新的事务操作到磁盘的操作会丢失，也就是主从复制的一致性无法保障，而 redo log 有 crash-safe 能力，通过与 redo log 的配合实现 "三步提交"，就可以让主从库的数据也能保证一致性。\n\n6、redo log 是物理日志，它记录的是数据页修改逻辑以及 change buffer 的变更，只能在当前存储引擎下使用，而 binlog 是逻辑日志，它记录的是操作语句涉及的每一行修改前后的值，在任何存储引擎下都可以使用。\n\n')])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br")])])])}),[],!1,null,null,null);n.default=l.exports}}]);